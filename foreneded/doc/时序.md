好的！我来根据你们现有软件的真实实现修改这些时序图，整理成一个完整的技术文档。

# 基于零知识证明的智能健康管理系统 - 技术流程文档

## 第一部分：初始设置与关系管理

### 图 1：身份创建与本地安全初始化

**作用**：确保用户在首次使用时就拥有完全由自己掌控的密钥，并在注册后能够使用生物识别快速解锁。

```mermaid
sequenceDiagram
    participant U as 用户
    participant App as 老人App
    participant Secure as 本地安全模块
    participant Gateway as API网关

    U->>App: 首次打开 App
    App->>Secure: 生成/导入 EOA + Smart Account
    App->>Secure: 加密保存密钥，可选开启生物识别解锁
    App->>Gateway: 注册账号，登记地址与公钥
    Gateway-->>App: 返回用户档案
    App->>U: 显示主页，引导下一步（添加家人等）
```

---

### 图 2：建立关系与访问组

**作用**：老人用二维码邀请家属加入访问组，双方完成关系确认后再互相发送必要资料，保证隐私和可控范围。

```mermaid
sequenceDiagram
    participant Elder as 老人App
    participant Rel as 关系服务
    participant Exchange as 安全交换
    participant Family as 家属App

    Elder->>Rel: 创建访问组与邀请
    Rel-->>Elder: 返回二维码
    Family->>Rel: 扫码接受邀请
    Rel-->>Family: 关系建立成功
    Elder->>Exchange: 发送加密资料
    Family->>Exchange: 回传自己的资料
    Exchange-->>Both: 通知已收到并存档
```

---

### 图 3：医生创建用药计划

**作用**：医生基于患者公钥编写密文计划，服务器只存加密内容，患者解密后即可按提醒执行。

```mermaid
sequenceDiagram
    participant Doctor as 医生App
    participant PlanSvc as 用药计划服务
    participant Exchange as 安全交换
    participant Patient as 患者App

    Doctor->>Doctor: 使用患者公钥撰写并加密计划
    Doctor->>PlanSvc: 提交密文供归档
    PlanSvc-->>Doctor: 返回计划编号
    Doctor->>Exchange: 把密文推送给患者
    Patient->>Exchange: 拉取密文并解密
    Patient->>Patient: 保存计划并设置提醒
```

---

## 第二部分：日常使用流程

### 图 4：每日用药打卡

**作用**：患者在本地完成证明和记录，既能离线保存，也能在需要时分享给家属或提交上链。

```mermaid
sequenceDiagram
    participant Patient as 患者App
    participant ZKP as 本地ZKP
    participant LocalStore as 本地存储
    participant Family as 家属App

    Patient->>ZKP: 依据计划生成证明
    ZKP-->>Patient: 返回证明与摘要
    Patient->>LocalStore: 保存记录与状态
    Patient->>Patient: UI 展示“已完成”
    Family->>Family: 如已同步，可查看该日记录；否则提示等待分享
```

---

### 图 5：本地通知与用药提醒

**作用**：系统根据用药计划自动推送提醒，患者可在本地查看历史记录和提醒日历，确保按时服药。

```mermaid
sequenceDiagram
    participant Patient as 患者App
    participant LocalStore as 本地存储
    participant Notify as 通知服务

    Patient->>LocalStore: 保存用药计划
    LocalStore-->>Patient: 返回计划数据
    Patient->>Notify: 注册提醒服务
    Notify->>Patient: 推送提醒
    Patient->>Patient: 显示提醒日历
    Patient->>LocalStore: 查询历史记录
    LocalStore-->>Patient: 返回历史记录
```

---

## 第三部分：周度汇总与上链

### 图 6：周度汇总 ZKP 生成（云端异步任务）

**作用**：前端提交周度 Merkle Root/leaves 后，云端异步生成周证明并返回 jobId，前端轮询状态获取 proof/publicSignals/calldata。

```mermaid
sequenceDiagram
    participant App as 患者App
    participant ZKPSvc as 云端ZKP服务

    App->>ZKPSvc: 提交周度输入（merkleRoot/leaves）
    ZKPSvc-->>App: 返回 jobId
    loop 轮询 job 状态
        App->>ZKPSvc: 查询 proofStatus(jobId)
        ZKPSvc-->>App: 返回 processing / completed(含proof)
    end
```

---

### 图 7：周度证明上链流程（IPFS + ERC-4337 UserOp）

**作用**：展示周度证明完成后如何上链：后端先把证明与记录打包上传 IPFS，再构建并提交 UserOp 调用智能账户合约记录 CID，最后通过通知回传交易结果。

```mermaid
sequenceDiagram
    participant App as 患者App
    participant ChainSvc as 链服务
    participant IPFS as IPFS(Pinata)
    participant Bundler as Bundler/EntryPoint
    participant SA as Smart Account(AA合约)
    participant Notify as 通知服务

    App->>ChainSvc: POST /chain/medication-checkin/submit
    ChainSvc->>IPFS: 上传周度证明/记录 JSON
    IPFS-->>ChainSvc: 返回 ipfsCid
    ChainSvc-->>App: 立即返回 ipfsCid（处理中）

    ChainSvc->>Bundler: 构建/签名/提交 UserOp(recordMedicationCheckIn(ipfsCid))
    Bundler->>SA: EntryPoint.handleOps 执行写入 CID
    Bundler-->>ChainSvc: 返回 txHash
    ChainSvc->>Notify: 推送上链结果通知
    Notify-->>App: 通知 confirmed/failed + txHash
```

---

## 第四部分：账户管理与安全

### 图 8：账户迁移（设备更换）

**作用**：展示用户在更换手机时，如何通过一次安全的迁移流程，把原来设备上的密钥、打卡记录和用药计划完整搬到新设备上，全程由用户自己掌控密码。

```mermaid
sequenceDiagram
    participant OA as 旧设备 App
    participant Bio as 生物识别
    participant B as 迁移服务
    participant NA as 新设备 App

    OA->>OA: 用户点击“账户迁移”
    OA->>Bio: 进行生物识别验证
    Bio-->>OA: 验证通过

    Note over OA: 收集本地需要迁移的数据
    OA->>OA: 用迁移密码（6 位 PIN）本地加密所有数据

    OA->>B: 创建迁移会话并上传加密数据
    B-->>OA: 返回 session_id 和确认码（用于扫码/校验）
    OA->>OA: 展示二维码和确认码给用户

    Note over NA: 新设备准备迁移
    NA->>NA: 扫描二维码，获取 session_id
    NA->>NA: 用户输入确认码
    NA->>B: 校验并拉取加密数据
    B-->>NA: 返回加密数据

    Note over NA: 在新设备上解密和恢复
    NA->>NA: 用户输入迁移密码
    NA->>NA: 解密并恢复密钥、计划和记录到本地
    NA->>Bio: 设置新的生物识别
    Bio-->>NA: 设置完成

    NA->>B: 通知迁移完成
    NA->>NA: 显示“迁移成功”，自动登录
```

---

### 图 9：社交恢复（抽象账户 AA + Guardian）

**作用**：展示社交恢复的核心思路：由守护者协助发起/确认恢复操作，最终通过 ERC-4337 执行账户合约恢复逻辑，将 Owner 更新为新地址。

```mermaid
sequenceDiagram
    participant User as 用户App（新设备）
    participant Guardian as 守护者(App/钱包)
    participant Gateway as API网关
    participant Bundler as Bundler/EntryPoint
    participant SA as Smart Account(AA合约)

    User->>Gateway: 构建恢复 UserOp
    User->>Guardian: 守护者确认/签名
    User->>Gateway: 提交恢复 UserOp
    Gateway->>Bundler: 提交到 EntryPoint
    Bundler->>SA: 执行恢复逻辑（Owner 更新）
    Gateway-->>User: 返回恢复结果/状态
```

---

### 图 10：关系解绑与权限撤销

**作用**：当老人和家属不再需要互相关联时，通过一次解绑操作，双方本地权限和服务器上的访问都同步失效，后续任何访问尝试都会被拒绝。

```mermaid
sequenceDiagram
    participant Elder as 老人App
    participant Rel as 关系服务
    participant Family as 家属App
    participant Exchange as 安全交换

    Elder->>Rel: 发起解除关系申请
    Rel-->>Elder: 确认解绑并推送通知
    Rel-->>Family: 同步通知关系已解除

    Elder->>Elder: 清除本地信任名单和访问权限
    Family->>Family: 同步清除本地访问权限

    Family->>Exchange: 若再尝试发送加密消息
    Exchange-->>Family: 拒绝请求（关系不存在）
```

---

## 第五部分：隐私保护机制

---

### 图 11：端到端加密通信完整流程

**作用**：概括展示一次端到端加密通信的关键步骤：发送方用接收方公钥加密并签名，服务器只做密文中转，接收方拉取后验证签名并在本地解密，保证服务器全程看不到明文。

```mermaid
sequenceDiagram
    participant A as 发送方App
    participant Crypto as 加密模块
    participant B as 安全交换服务
    participant R as 接收方App

    A->>A: 准备要发送的明文数据
    A->>Crypto: 使用接收方公钥加密数据 (ECIES)
    Crypto-->>A: 返回密文 encrypted_data

    A->>Crypto: 使用自己的私钥对密文签名 (ECDSA)
    Crypto-->>A: 返回签名 signature

    A->>B: 提交加密消息 { encrypted_data, signature, recipient }
    B->>B: 验证签名有效性
    B->>B: 仅以密文形式存储并标记接收方
    B-->>R: 通知接收方“有新消息”

    R->>B: 拉取自己未读的加密消息
    B-->>R: 返回 encrypted_data 和 signature

    R->>Crypto: 使用发送方地址验证签名
    Crypto-->>R: 验证通过

    R->>Crypto: 使用本地私钥解密 encrypted_data
    Crypto-->>R: 得到明文数据并返回给App
    R->>R: 在本地展示并存储解密后的内容
```

---

### 图 12：零知识证明（ZKP）本地生成详解

**作用**：概括展示客户端本地生成零知识证明的核心流程，从准备输入、调用电路到得到证明和公开信号并保存，为后续上链验证做好sequenceDiagram

```mermaid
    participant UI as 用户界面
    participant ZKP as 本地ZKP服务
    participant Circuit as 证明电路 (WASM)
    participant Store as 本地存储

    UI->>ZKP: 传入用药打卡相关输入 generateMedicalProof(input)
    ZKP->>ZKP: 在本地整理私有输入和时间等电路参数

    ZKP->>Circuit: 调用电路生成证明和 publicSignals
    Circuit-->>ZKP: 返回 { proof, publicSignals }

    ZKP->>ZKP: 生成适配智能合约的 calldata
    ZKP-->>UI: 返回 proof、publicSignals 和 calldata

    UI->>Store: 把证明结果和打卡记录一起存到本地
    Store-->>UI: 保存成功，用于后续查看或上链
```

---

## 系统特点总结

### 1. **完全本地化的隐私保护**

- 私钥存储在手机安全硬件，使用生物识别加密
- ZKP证明在本地生成，服务器无法获取原始数据
- 打卡记录保存在本地Capacitor存储

### 2. **端到端加密通信**

- 使用ECIES（secp256k1）加密，服务器只做盲目转发
- ECDSA签名确保消息真实性和完整性
- 用药计划、用户信息全程加密

### 3. **灵活的权限控制**

- 基于访问组的细粒度权限管理
- 通过本地白名单机制快速拒绝非法访问
- 支持动态解绑和权限撤销

### 4. **无密码体验**

- 基于生物识别的身份验证
- 社交恢复机制（Guardian多签）
- 无需记忆助记词或密码

### 5. **本地优先架构**

- 本地通知，无需后端定时任务
- 本地存储，支持离线查看
- 本地ZKP验证（view函数免费调用）

---

**文档版本**: v1.0
**最后更新**: 2025-11-05
**技术栈**: Vue 3 + TypeScript + Capacitor + ethers.js + snarkjs + Poseidon Hash
